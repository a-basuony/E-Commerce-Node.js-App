
1- npm init --save
2- npm install express --save  => to run server (node app.js)
3- npm install -D nodemon => to restart the server automatically (nodemon app.js) or in  package.json add "start": "nodemon app.js" to "scripts" => (npm start) or add "dev": "nodemon app.js" to "scripts" => (npm run dev)

4- Environment  Variables:
    => npm install dotenv
    => create file config.env : this file has   
    :=> .env   => it's a file that will store all the environment variables
    - NODE_ENV=development / production
    - PORT=3000
    => to access  the env variable in your code 
        :=> you can use:
            const dotenv = require('dotenv')
            dotenv.config({path: 'config.env'})  // config.env is the name of the file
            console.log(process.env.NODE_ENV);
            const PORT = process.env.PORT || 3000;
            app.listen(PORT, () => {
                console.log("App running on  port ", PORT);
            });

5-.gitignore file : to specify the files and directories that should be excluded from version control
    => # dependencies
        node_modules/

        # environment files
        .env
        config.env

6- morgan : . It is an HTTP request logger that can be used to log HTTP requests, response status, response time, and other request and response metadata.
              This format incorporates some of the most relevant information about the HTTP requests, such as the request method, request URL, response status, response time, and response headers.
               EX: // GET / 304 5.093 ms - -

          what is middleware? :  it's a function that runs  there is a request or response
               هي باختصار حاجه بين الريكوست والريسبونس يعني ببساطه جايلي ريكوست هنعمل شويه حجات عليه قبل مبعت الريسبونس 
               دائماً الميدل وير بتكون قبل مبعت الرووت
        
        => npm install morgan
        => const morgan = require("morgan");
        => if (process.env.NODE_ENV === "development") {
                app.use(morgan("dev")); // Log HTTP requests in development 'dev' mode relevant information about the HTTP requests, such as the request method, request URL, response status, response time, and response headers
                console.log("mode:", process.env.NODE_ENV); // GET / 304 5.093 ms - -
            }

9- morgan : is a popular HTTP request logger middleware for Node.js.
            . It simplifies the process of logging requests in your application by automatically logging request details
             such as method, URL, status code, response time, and more.
             It is easy to use and can be integrated into your Node.js applications with just a few lines of code.

    => // Use Morgan middleware to log HTTP requests
        app.use(morgan('dev'));

 

7- Use Mongodb (NOSQL)
    => install Mongodb (locally => not recommended)   or using (MongoDB Atlas) as a hosted service
    => we will use MongoDB Atlas after login
            - create database ( cluster=> collection) => copy database name
            - create Database Access(username, password) => copy username, password
            - Database Access
            - connect with MongoDB Compass locally as a GUI تستعرضها علي الاب عندك
            - copy the ( connection string) => copy connection string
    
    => connect app to MongoDB using (Mongoose)
        - install Mongoose => npm install mongoose
        - database connection string => DB_URI=mongodb+srv://<username>:<password>@cluster0.2jgswxg.mongodb.net/<DB-name>
        - app.js : 
                - const mongoose = require("mongoose");
                - mongoose
                        .connect(process.env.DB_URI)
                        .then((conn) => {
                            console.log("connected to database successfully!", conn.connection.name);
                        })
                        .catch((err) => console.log("Database Error", err));
                - (document , collection , field ) MongoDB
                        user = {id:123, name:"ah" ,age: 20}  in sql : id,name,age => column ,  in Mongo: id,name,age => field
                            {id:123, name:"ah" ,age: 20}  = row => in sql , in Mongo => document
                            user => table in sql ,in Mongo => collection

    => create model folder => category.js file 
    => add dataBase models by creating:  1- create the schema for our user model
                                         2- create a Model using the CategorySchema 
                                         3- export this model so other files can access it

                                    Example :
                                                const mongoose = require("mongoose");

                                                const Schema = mongoose.Schema;
                                                
                                                // 1- create the schema for our user model
                                                const categorySchema = new Schema(
                                                {
                                                    name: {
                                                    type: String,
                                                    required: [true, "Category  name is required"], //  this means that if we don't provide a value for it , an error will be thrown and its message: "Category  name is required"
                                                    unique: [true, "Category  already exists"],
                                                    minlength: [3, "Name must be at least 3 characters"],
                                                    maxlength: [32, "Too long category name"],
                                                    },
                                                    // Ahmed Basuony => shopping.com/ahmed-basuony  (space => -, lowercase )
                                                    // so we use slugify package  to make it like that
                                                    slug: {
                                                    type: String,
                                                    lowercase: true,
                                                    },
                                                    image: String,
                                                },
                                                { timestamps: true } // to add two fields  createdAt & updatedAt in DB to know category knew  or not
                                                );

                                                //  2- create a Model using the CategorySchema
                                                module.exports = mongoose.model("Category", categorySchema);


8-Folder Structure : 
        - src
            - public
                - images
                - Css
                - JS
              - models
                   - category.js
              - routes
                   - categories.js
              - controllers or (services)
                      - categories.js
              - views
                      - index.ejs
                      - layouts
              - config 
                       - db.config.js
              - app.js




11- slugify  : It will convert your text into lowercase letters and replace spaces into dash -
            // Ahmed Basuony => shopping.com/ahmed-basuony  (space => -, lowercase )
            // so we use slugify package  to make it like that
    
    => install : npm i slugify 
    => how to use it : 
                        const slugify = require('slugify')
                        slugify('Ahmed Mohamed  Basuony',{lower: true}) 
                         => 'ahmed-mohamed-basuony'
                        Ex:  const name = req.body.name;   
                             CategoryModel.create({ name: name, slug: slugify(name) })


13- you can use 
            router.route("/").get(createCategory).post(createCategory);
            // instead of
            // router.get("/", createCategory);
            // router.post("/", createCategory);



14- Write a documentation for you'r api as a comments

        1- put the comment on top of your file like this:
        2- @desc  describe what is the method do
        3- @access public or private  (if it is private for admin , if it is public for users)
        4- @type get or post ... etc
            or => @route GET /api/categories
        5- @param {type} paramName description of the parameter

                /**
                // @desc Get all categories
                // @route GET /api/categories
                // @access Public
                */
                const getCategories = asyncHandler(async (req, res) => {
                const categories = await CategoryModel.find({});
                res.status(200).json({ results: categories.length, data: categories });
                });
                    
                /**
                // @dec  Get list of categories
                // @route POST /api/v1/categories
                // @access Private       //=> ( for admin only)
                */
                const createCategory = asyncHandler(async (req, res) => {
                const name = req.body.name;
                const category = await CategoryModel.create({
                    name: name,
                    slug: slugify(name),
                });
                res.status(201).json({ data: category });
                });




12- CRUD operation using Mongoose: 
        ===================== create ========================
        1- const CategoryModel = require("../models/categoryModel");

        2- app.post('/categories', async (req , res)=>{
                try {
                    const category = await CategoryModel.create(req.body, slug: slugify(name)) ;
                    res.json(category);
                } catch (error) {
                    res.status(400).send(error);    
                }
        });

        
                 const name = req.body.name;
            //   const newCategory = new CategoryModel({ name, slug: slugify(name) });
            //   newCategory
            //     .save()
            //     .then((doc) => {
            //       res.json(doc);
            //     })
            //     .catch((err) => res.json(err));



        (or)  using express-async-handler package

            for handling  async function in route handler
            Simple middleware for handling exceptions inside of async express routes and passing them to your express error handlers.
             
            => install : npm i express-async-handler

            => const asyncHandler = require("express-async-handler");
                
            => const createCategory = asyncHandler(async (req, res) => {
                    const name = req.body.name;
                    const category = await CategoryModel.create({ name: name, slug: slugify(name) });
                    res.status(201).json({ data: category });
                });


15- pagination
    @doc Paginate array of objects using page and limit query parameters
    
        => first get page and limit and convert them to skip and limit to send  to mongoose
        => (get)
                  const page = req.query.page * 1 || 1; // * 1 to convert string to number and set 1 as a  default value if no page provided
                  const limit = req.query.limit * 1 || 5;    // default value is 5
                  const skip = (page - 1) * limit; /// ex: (2-1)*5=5  // to show number of page should skip them to  show the next page content (limit)

        => .skip(skip).limit(limit)   - this will return an array of documents from db
            to paginate   
            const categories = await CategoryModel.find({}).skip(skip).limit(limit);




=============== Error Handler =========================
16- Error handler
    1- .then() .catch(err => )
    2- try{} catch(err){}
    3- asyncHandler(async) ==> express error handler ( CastError: Cast to ObjectId failed )
      => how to handle express error and convert it to json format

       1 => Global  Error Handling middleware and  use it in the main file app.js
           used to convert error from html to json format
        
            // Global Error Handling Middleware
            app.use((err, req, res, next)=>{
            res.status(500).json(err)
            })
        
        2 =>  Generate Error and send it back to the client if the route is not found 
            // if the route is not found  then call a function that generate a custom error 
            app.all("*", (req, res, next) => {

                // create error and send it to error handling middleware
                // create  a response error to send data back to the client
                const err = new Error(`Can't find this  route ${req.originalUrl}`);
                next(err.message);
                ------------------------------------------------------------

                // instead of we will create a class to reusable error
                // reusable error => class will take message and statusCode
                // then you can call it like that : `new ApiError('message', statusCode)`

                  next(new ApiError(`Can't find this  route ${req.originalUrl}`, 400));
            });

        => the Global Error Handling middleware 
                            app.use((err, req, res, next) => {
                                err.statusCode = err.statusCode || 500;
                                err.status = err.status || "error";

                                res.status(err.statusCode).json({
                                    status: err.status,
                                    error: err,
                                    message: err.message,
                                    stack: err.stack, // where the error and details
                                });
                            });

         => use  ApiError class in controller or service if there are an error 
            you can use it 
            on operations (getCategoryById , updateCategory, deleteCategory)

            EX: of delete category 
            :
                const category = await Category.findByIdAndDelete(id);
                1- const  ApiError = require('../utils/apiError');
                2-   if (!category) {
                        // res.status(404).json({ message: `No category for this id ${id}` });
                        return next(new ApiError(`No category for this id ${id}`, 404));
                    }

                    don't forget to return next(new ApiError()) after catching an error
                    because if we don't return it it gives us {"data": null}
                    because it will continue to next line which is   res.status(200).json({ data: category });

  => in development mode i need to return this response 
                                                        res.status(statusCode).json({
                                                            status: status,
                                                            error: err,
                                                            message: message,
                                                            stack: err.stack, // where the error and details // (OR) Log the error stack trace
                                                        });  
                                                    Ex:  {
                                                            "status": "fail",
                                                            "error": {
                                                                "statusCode": 404,
                                                                "status": "fail",
                                                                "operational": true
                                                            },
                                                            "message": "No category for this id 6600f9610c6a6cfd1e62a6dc",
                                                            "stack": "Error: No category for this id 6600f9610c6a6cfd1e62a6dc\n    at D:\\projects\\Nodejs\\E-Cmmerce Node.js Udemy\\services\\categoryService.js:31:17\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)"
                                                        }

    
  => in production mode i need to return this response : 
                                   res.status(statusCode).json({
                                       status,
                                       message
                                   })

                                   EX: {
                                            "status": "fail",
                                            "message": "No category for this id 6600f9610c6a6cfd1e62a6dc"
                                        }

   => run the app in with "scripts" in package.json 

                - development mode => "start:dev": "nodemon server.js",
                    => npm run start:dev
                - production mode => "start:prod": "SET \"NODE_ENV=production\" && node server.js"
                    => npm run start:prod


 => handle Errors outside express like authenticate with mongodb
    i was catch the error in 
                            -   // .catch((err) => {
                                //   console.log("Database Error", err);
                                //   process.exit(1); // to shutdown the app
                                // });

    - instead of i will do in the end of server.js file 

                1- listen on event unhandledRejection using {process.on()}
                2- inside that event i expect the error and i will console it
                3- close the server using {server.close()}
                4- inside close  event also i will console the error and shutdown the app using{ process.exit(1)}

            const server = app.listen(3000)
            // Handle rejection outside express

            process.on("unhandledRejection", (err) => {
            // console.log(err);
            console.log(`UnhandledRejection Errors: ${err.name} | ${err.message}`); //=> UnhandledRejection Errors: MongoServerError | bad auth : Authentication failed.
            server.close(() => {
                console.log("Shutting down...");
                process.exit(1); // to shutdown the app
            });
            });



17- Validation layer : using express validator
            install: npm install express-validator
            
            getCategory ById ==> used in addProduct & updateProduct handlers

            => working with id => use param  for getting the params from url 
               const { param, validationResult } = require('express-validator');
            
            => working with body => use body  for getting the body 
               const { body, validationResult } = require('express-validator');

            => working with body and id => use check  for getting the body or id
            
               const { check, validationResult } = require('express-validator');

               check('id').isMongoId().withMessage('Invalid ID')
               check(body).isLength({ min: 5 }).withMessage('Too short!')

           

            1- rules 
                we use param 
                :  const { param, validationResult } = require('express-validator');
                : param('id').isMongoId().withMessage('Invalid Category ID')
                
            2- middleware => catch errors from rules if exist

                 (req, res, next) => {
                        const errors = validationResult(req);
                        if (!errors.isEmpty()) {
                            return res.status(400).json({ errors: errors.array() });
                        }
                        next();
                    },


             Ex: // Middleware to validate the ID parameter
                        const validateIdParam = [
                            // 1- rules
                            param('id').isInt({ min: 1 }).withMessage('Invalid ID parameter'),

                            // 2- middleware to catch errors from rules if  they exist
                            (req, res, next) => {
                                // finds the validation error in req and wraps them in an object

                                const errors = validationResult(req);
                                if (!errors.isEmpty()) {
                                return res.status(400).json({ errors: errors.array() });
                                }
                                next();
                            },
                        ];


                    Ex: router.route('/:id').get(validateIdParam , getCategory);







   => catch error from express using error handling middleware 
   => Handle unhandled routes and send error to error handling middleware 
   => make our reuseable error class
   => Handle Errors in development and production env 
   => handle errors outside express (unhandled Rejections)
   => Validation Layer benefits and implementation


18- working with sub model like : subCategory  belongsTo Category ----->  Category.js Model file
                         

                         const mongoose = require("mongoose");

                                    const subCategorySchema = new mongoose.Schema(
                                    {
                                        name: {
                                            type: String,
                                            trim: true,
                                            unique: [true, "SubCategory must be unique"],
                                            minLength: [2, "Name must have at least 2 characters"],
                                            maxLength: [30, "Name can't exceed 30 characters"],
                                        },

                                        slug: {
                                            type: String,
                                            lowerCase: true,
                                        },

                                        //each subcategory must belong to a parent category.

                                        category: {
                                            type: mongoose.Schema.ObjectId, 
                                            ref: "Category",
                                            required: [true, "SubCategory must be belong to parent category"],
                                        },
                                    },
                                    { timestamps: true }
                                    );

                                    module.exports = mongoose.model("SubCategory", subCategorySchema);

                    
                    to create sub model => 
                        category:{} => is a reference to another Mongoose model ("Category") and is required.
                                   
                                                //each subcategory must belong to a parent category.
                                        category: {
                                            type: mongoose.Schema.ObjectId,  
                                                // set to mongoose.Schema.ObjectId, which represents a unique identifier for a document in MongoDB. This indicates that the "category" field will store the unique ID of a document from another collection (in this case, the "Category" collection).
                                                //The "category" field stores the unique ID of the parent category,
                                            ref: "Category", 
                                                // the ref option establishes a relationship between the "SubCategory" and "Category" models.
                                                // It specifies the name of the referenced model. In this case, it indicates that the "category" field refers to documents in the "Category" model.
                                            required: [true, "SubCategory must be belong to parent category"],
                                        },

19- The `.populate()` method in Mongoose is used to retrieve and include related data from other documents or models,
    based on defined relationships. It simplifies data fetching by automatically replacing references with actual related documents.


    to show the parent category in the "SubCategory" model as a child of the "Category" model you need to populate it.

 .populate({
    path: "category", // the name of field in model
    select: "name - _id - filedName",   
  })
                                     /**
                                            * @desc     Get all SubCategories
                                            * @route    GET /api/v1/Subcategories
                                            * @access   Public
                                            */
                                            exports.getSubCategories = asyncHandler(async (req, res, next) => {
                                            const page = req.query.page || 1;
                                            const limit = req.query.limit || 5;
                                            const skip = (page - 1) * limit;

                                            const subCategory = await SubCategory.find({})
                                                .skip(skip)
                                                .limit(limit)
                                                .populate({ path: "category", select: "name -_id" });
                                            // is used to fetch and include data from another collection related to the current one, and specify which fields from the related documents should be included in the response.
                                            //This populates the "category" field in the subcategory documents, selecting only the "name" field and excluding the "_id" field from the related category documents.
                                            if (!subCategory) {
                                                next(new ApiError("Failed to get Subcategories", 400));
                                            }
                                            res
                                                .status(200)
                                                .json({ results: subCategory.length, page, data: subCategory });
                                            });

                                            Example: {
                                                        "_id": "6612d9f863d08fc4f20ed3a1",
                                                        "name": "HP",
                                                        "slug": "HP",
                                                        "category": {
                                                            "name": "Clothes And Shoose",
                                                        },
                                                        "createdAt": "2024-04-07T17:38:00.057Z",
                                                        "updatedAt": "2024-04-07T17:38:00.057Z",
                                                        "__v": 0
                                                    },



              the parent category in the "SubCategory" model as a child of the "Category" model you need to populate       

              --------------
                populate({ path: "category", select: "name -_id" });   // the parent category in the "category" 

            ==> "category"  refers to the category field in "subCategory" model
            ==> select "name" refers to the name field in "category" model the parent
            ==> -_id to remove the id from the "category" model

                category: {
                        type: mongoose.Schema.ObjectId, 
                        ref: "Category", 
                        required: [true, "SubCategory must be belong to parent category"],
                    },


       use cases     ------------------- 1- show category the parent category with all fields --------
            with =>  .populate({ path: "category"});

            ex: "category": {
                                    "_id": "66082b89921a97fa27a5f5d9",
                                    "name": "Clothes And Shoose",
                                    "slug": "clothes-and-shoose",
                                    "createdAt": "2024-03-30T15:11:05.360Z",
                                    "updatedAt": "2024-03-30T15:11:05.360Z",
                                    "__v": 0
                                },

                    ----------- 2- remove id from the parent and show the name fields only ----------------
                .populate({ path: "category", select: "name -_id" });

                ex:  "category": {
                                "name": "Clothes And Shoose"
                            },

                 -------------- 3-  show the id automatically and name field with select --------------

                    .populate({ path: "category", select: "name" });
                    ex:    "category": {
                                "_id": "66082b89921a97fa27a5f5d9",
                                "name": "Clothes And Shoose"
                            },


        disadvantage of populate 
            While the `.populate()` method in Mongoose simplifies data retrieval for related documents,
              it can introduce performance overhead, complexity, data consistency issues,
              overfetching / underfetching, security concerns, and limited flexibility. 
              It relies on proper schema design and may not suit all use cases, 
              especially complex queries. It also consumes memory and has a learning curve.



20- Get all subcategories for specific category (Nested Route)  
    get list of subcategories for specific category

    (nested route)
    get child from parent 
    Example:
    * GEt /api/v1/categories/:categoryId/subcategories
    * GEt /api/v1/products/:productId/reviews

    /api/v1/categories (category route)   /:categoryId/subcategories (subcategory route)

    1- categoryRoute =>   
          path =>   /api/v1/categories/:categoryId/subcategories  (go to => subcategoriesRoute)

                      const subcategoriesRoute = require('./subcategoryRoute')
                      router.use('/:categoryId/subcategories' , subcategoriesRoute)


   2- subcategoryRoute => 
                        const router = express.Router({mergeParams: true})

                        // mergeParams allow us to access parameters on other routers 
                        // example : we need to access categoryId from category router
                        // in subcategoryRoute  we need to access categoryId from category router
                           subcategoryRoute => use categoryId from category router as parameter

                           let filterObject = {}
                           if(req.params.categoryId) filterObject = {category: req.params.categoryId}
                           
                           const subCategories = await SubCategory.find(filterObject)

                           example:
                            exports.getSubCategories = asyncHandler(async (req, res, next) => {
                                            const page = req.query.page || 1;
                                            const limit = req.query.limit || 5;
                                            const skip = (page - 1) * limit;

                                            let filterObject = {};
                                            if (req.params.categoryId) {
                                                filterObject = { category: req.params.categoryId };
                                            }
                                            // console.log("Filter Object:", filterObject);

                                            const subCategory = await SubCategory.find(filterObject)
                                                .skip(skip)
                                                .limit(limit)
                                                .populate({ path: "category", select: "name" })

                                            // -_id;
                                            // is used to fetch and include data from another collection related to the current one, and specify which fields from the related documents should be included in the response.
                                            //This populates the "category" field in the subcategory documents, selecting only the "name" field and excluding the "_id" field from the related category documents.
                                            if (!subCategory) {
                                                return next(new ApiError("Failed to get Subcategories", 400));
                                            }
                                            res
                                                .status(200)
                                                .json({ results: subCategory.length, page, data: subCategory });
                                        });


21- Create SubCategory on Category (nested Route)

                1- // middleware used to create an object (filterObject) based on categoryId from req.params
                    //  it sets the category field in the filterObject to the categoryId
                    // Then, it assigns the filterObject to the req.filterObj property

                    1=> exports.createFilterObj = (req, res, next) => {
                            let filterObject = {};
                            if (req.params.categoryId) {
                                filterObject = { category: req.params.categoryId };
                            }
                            req.filterObj = filterObject;
                            next();
                        };

                        2=> exports.getSubCategories = asyncHandler(async (req, res, next) => {
                                const page = req.query.page || 1;
                                const limit = req.query.limit || 5;
                                const skip = (page - 1) * limit;
                                // console.log("Filter Object:", filterObject);
                                const subCategory = await SubCategory.find(req.filterObj)
                                    .skip(skip)
                                    .limit(limit)
                                    .populate({ path: "category", select: "name" })
                                    if (!subCategory) {
                                            return next(new ApiError("Failed to get Subcategories", 400));
                                        }
                                        res
                                            .status(200)
                                            .json({ results: subCategory.length, page, data: subCategory });
                             });

                             3=> router
                                    .route("/")
                                    .get(createFilterObj, getSubCategories)
                ----------------------------
                2- middleware function that is used to set the category field in the request body to the categoryId from the request params
                    1=> 
                        exports.setCategoryIdToBody = (req, res, next) => {
                            if (!req.body.category) {
                                req.body.category = req.params.categoryId;
                            }
                            next();
                        };

                    2=> 
                        exports.createSubCategory = asyncHandler(async (req, res) => {
                                const { name, category } = req.body;
                                const subCategory = await SubCategory.create({
                                    name: name,
                                    slug: slugify(name),
                                    category, //  as a body it will be added as a subcategory of the provided category
                                });

                                if (!subCategory) {
                                    throw new ApiError("Failed to create Subcategory", 400);
                                }
                                res.status(201).json({ data: subCategory });
                                });

                        3=> router
                            .route("/")
                            .post(setCategoryIdToBody, createSubCategoryValidator, createSubCategory);

    ---------------------------- SUMMARY -------------------------
    - Category CRUD operations 
    - SubCategory CRUD operations 
    - Brands CRUD operations 
    - validation
    - Eslint configurations
    - Populate()  select()
    - Nested Routes with {mergeParams: true}

            (notes)
                => price type Number (when create a model) 
                    maxLength - max : [number, "error message"]
                    minLength - min : [number, "error message"]

                => description type String 
                        => maxLength - maxlength : [number, "error message"]
                        => minLength - minlength : [number, "error message"]


22- create product model => product Service => product Validator 

       1 => product Validator
                = you can create a custom validator 
                => to check if the category existence in our DB
                        .custom((categoryId, { req }) =>
                            Category.findById(categoryId).then((category) => {
                                if (!category) {
                                return Promise.reject(
                                    new Error(`No category for this id: ${categoryId}`)
                                );
                                }
                            })
                            ),  

              
                 Full Example    check("category")
                                    .notEmpty()
                                    .withMessage("product must be belong to a category")
                                    .isMongoId()
                                    .withMessage("Category must be a valid MongoDB ObjectId")
                                    .custom((categoryId, { req }) =>
                                        Category.findById(categoryId).then((category) => {
                                            if (!category) {
                                            return Promise.reject(
                                                new Error(`No category for this id: ${categoryId}`)
                                            );
                                        }
                                    })
                                    ),



        2- in product Validator 
            => check on subCategories id as an array of Ids
              to check if subCategories existence in my DB before adding product

                .custom((subcategoriesIds) =>
                            Subcategory.find({ _id: { $in: subcategoriesIds } }).then( (result) =>{
                                if(result.length < 1 || result.length !== subcategoriesIds){
                                return Promise.reject(
                                    new Error("Invalid subcategory id format")
                                );
                                }
                            })
                ),

           Example:     check("subcategories")
                            .optional()
                            .isMongoId()
                            .withMessage("Subcategory must be a valid MongoDB ObjectId")
                            .custom((subcategoriesIds) =>
                                Subcategory.find({ _id: { $exist: true, $in: subcategoriesIds } }).then( (result) =>{
                                    if(result.length < 1 || result.length !== subcategoriesIds){
                                    return Promise.reject(
                                        new Error("Invalid subcategory id format")
                                    );
                                    }
                                })
                            ),

        2- in product Validator 
              => check and validate Subcategories belong to Category


                    .custom(async (subcategoriesIds, { req }) => {
                            const categoryId = req.body.category; 
                            const subcategories = await Subcategory.find({
                                _id: { $in: subcategoriesIds },
                                category: categoryId,
                            });
                            if (subcategories.length !== subcategoriesIds.length) {
                                return Promise.reject(
                                new Error("Subcategories do not belong to the category")
                                );
                            }
                        }),  

                => another way to validate 
                            .custom((val, { req }) => {
                                        Subcategory.find({ category: req.body.category }).then(
                                            (subcategories) => {
                                            const subCategoriesIdsInDB = [];
                                            subcategories.forEach((subcategory) => {
                                                subCategoriesIdsInDB.push(subcategory._id.toString());
                                            });
                                            if (!val.every((v) => subCategoriesIdsInDB.includes(v))) {
                                                return Promise.reject(
                                                new Error("Subcategories do not belong to the category")
                                                );
                                            }
                                            }
                                        );
                                        })




23- insert & delete products dummy data using seeder script

        1- install colors package  
                - npm install colors 
                - used to that allows you to add colors to your console.log 

                example: (" will be printed in green color in the console.)

                        const colors = require('colors');

                        console.log('Hello, world!'.green);
                        console.log("Data Inserted".green.inverse);

        2- upload dummy data and seeder.js file (this data can i filter it and sort )
             => first we delete all stored data and then upload the dummy data

        3- run seeder.js file

                - node seeder.js -d   => to delete all data 
                - node seeder.js -i    => to to add dummy data 

24- filter in mongoose 

     send filter as a query params =>    localhost:3000/api/v1/products?price=109.95&ratingsAverage=4.3

     (best way) 1-   const products = await Product.find({
                                                price: req.query.price,
                                                ratingsAverage: req.query.ratingsAverage,
                                            })
                                            .skip(skip)
                                            .limit(limit)

     (or)  2-   const products = await Product.find({})
                                                .where("price")
                                                .equals(req.query.price)
                                                .where("ratingsAverage")
                                                .equals(req.query.ratingsAverage)
                                                .skip(skip)
                                                .limit(limit)
                                                .populate({ path: "category", select: "name -_id" });

        Example: 
                    exports.getProducts = asyncHandler(async (req, res, next) => {
                            const page = req.query.page * 1 || 1;
                            const limit = req.query.limit * 1 || 5;
                            const skip = (page - 1) * limit;

                            const products = await Product.find({
                                price: req.query.price,
                                ratingsAverage: req.query.ratingsAverage,
                            })
                                .skip(skip)
                                .limit(limit)
                                .populate({ path: "category", select: "name -_id" });
                            if (!products) {
                                return next(new ApiError("Products not found", 404));
                            }
                            res.status(200).json({ results: products.length, page, data: products });
                        });


      3- filtering 
            1- The function first creates a copy of the query string object and removes the fields that are not needed for filtering the products. like (These excluded fields are "page", "sort", "limit", and "fields".)
            2- Pagination: The function sets the default values for page and limit if they are not provided in the query string. It then calculates the number of documents to skip based on the current page and limit
            3- Build query: The function creates a Mongoose query using the filtered query string object. It also sets the number of documents to skip and limit, and populates the "category" field with the corresponding category name.
            4- Execute query: The function executes the Mongoose query and returns the results. (retrieves the products that match the query string filters.)
            5- Error handling: If no products are found, the function throws an ApiError with a message "Products not found" and a status code of 404.
            6- Response: If products are found, the function sends a JSON response with the number of results, the current page, and the retrieved products.

            Example: 
                    exports.getProducts = asyncHandler(async (req, res, next) => {
                            // 1- filtering
                            const queryStringObj = { ...req.query };
                            const excludesFields = ["page", "sort", "limit", "fields"];
                            excludesFields.forEach((field) => delete queryStringObj[field]);

                            // 2- pagination
                            const page = req.query.page * 1 || 1;
                            const limit = req.query.limit * 1 || 5;
                            const skip = (page - 1) * limit;

                            // 3-Build query
                            const mongooseQuery = Product.find(queryStringObj)
                                .skip(skip)
                                .limit(limit)
                                .populate({ path: "category", select: "name -_id" });

                            // 4- Execute query
                            const products = await mongooseQuery;

                            if (!products) {
                                return next(new ApiError("Products not found", 404));
                            }
                            // res.status(200).json({ results: products.length, page, data: products });
                            res.status(200).json({
                                status: "success",
                                results: results.length,
                                page,
                                data: products,
                            });
                            });


    => filtering with    (gte, gt, lte, lt)
                   
                            (greater than or equal to [gte])
                            (greater that [gt])
                            (less than or equal to [lte])
                            ( less that [lt])

            1- first in api we write that :

                        localhost:3000/api/v1/products?price[gte]=50&ratingsAverage[gte]=4
                        localhost:3000/api/v1/products?price[gt]=50&ratingsAverage[gt]=4
                        localhost:3000/api/v1/products?price[lte]=50&ratingsAverage[lte]=4
                        localhost:3000/api/v1/products?price[lt]=50&ratingsAverage[lt]=4

            2- second 
                    req   
                        => // { price: { gt: '109.95' }, ratingsAverage: { gt: '4.3' } }
                    we need to be like this for mongoose (to understand this is filtration) 
                        =>  //  { price: { $gt: '109.95' }, ratingsAverage: { $gt: '4.3' } }

                        1- filtering form other words that used in pagination and sort
                            const queryStringObj = { ...req.query };
                            const excludesFields = ["page", "sort", "limit", "fields"];
                            excludesFields.forEach((field) => delete queryStringObj[field]);

                        2-  //convert to string
                            let queryString = JSON.stringify(queryStringObj);
                            console.log("Before replace:", queryString); // Add this line for logging to see what happen
                            // Before replace: {"price":{"lte":"50"},"ratingsAverage":{"lte":"4"}}

                        3-  // use regex to add $ before (gte|ge|lte|lt) to understand mongo the query
                            MongoDB query operators ($gte, $gt, $lte, and $lt)
                            queryString = queryString.replace(
                                                        /\b(gte|gt|lte|lt)\b/g,
                                                        (match) => `$${match}`
                                                    );
                            console.log("After replace:", queryString);
                            //After replace: {"price":{"$lte":"50"},"ratingsAverage":{"$lte":"4"}}

                        4- // to convert string to a js object
                            const query = JSON.parse(queryString);
                            console.log("Parsed query:", query);
                            //Parsed query: { price: { '$lt': '50' }, ratingsAverage: { '$lt': '4' } }

                        5- // Build query (send query to mongoose model)
                        5- // Build query (send query to mongoose model)
                                 const mongooseQuery = Product.find(query)
                                                                .skip(skip)
                                                                .limit(limit)
                                                                .populate({ path: "category", select: "name -_id" });


25- Sorting Feature on products
                1- ascending order (from lowest to highest).
                  products/?sort=-price  (from hightest to lower in price) (-descending)
                2- descending order (from highest to lowest).
                  products/?sort=price (from lower to hightest in price) (+ascending)
                3- sorts a list of products by their ratings average and price 
                   products/?sort=-ratingsAverage,price (from hightest ratingsAverage to lower, price from lower to hightest )

                3- // Sorting if sort with one property (not recommended)
                        if( req.query.sort){
                            const sortBy = req.query.sort.split(',')
                            mongooseQuery = mongooseQuery.sort(req.query.sort)
                        }

                4- // Sorting for list or one or nothing(if nothing we will sort with createdAt the newest one) any property
                     if nothing sort send we will sort with createdAt the newest one (else{})

                    if(req.query.sort){
                        const sortBy = req.query.sort.split(',').join(' ')
                        mongooseQuery = mongooseQuery.sort(sortBy)
                    }else{
                        mongooseQuery = mongooseQuery.sort('-createdAt')
                    }

            Example: 
                                exports.getProducts = asyncHandler(async (req, res, next) => {
                                                    // 1) filtering
                                                    const queryStringObj = { ...req.query };
                                                    const excludesFields = ["page", "sort", "limit", "fields"];
                                                    excludesFields.forEach((field) => delete queryStringObj[field]);

                                                    //apply filtration using [gte, gt, lte, lt]
                                                    let queryString = JSON.stringify(queryStringObj);
                                                    queryString = queryString.replace(
                                                        /\b(gte|gt|lte|lt)\b/g,
                                                        (match) => `$${match}`
                                                    );
                                                    const query = JSON.parse(queryString);

                                                    // we need like this { price: { $gt: '109.95' }, ratingsAverage: { $gt: '4.3' } }
                                                    // 2) pagination
                                                    const page = req.query.page * 1 || 1;
                                                    const limit = req.query.limit * 1 || 5;
                                                    const skip = (page - 1) * limit;

                                                    // 3) Build query // to can chain methods on the query
                                                    let mongooseQuery = Product.find(query)
                                                        .skip(skip)
                                                        .limit(limit)
                                                        .populate({ path: "category", select: "name -_id" });

                                                    // 4) Sorting(one or list or nothing)
                                                    if (req.query.sort) {
                                                        // convert from 'price, average' => 'price average'
                                                        // 'price, average' split(',') => ['price', 'average'] join(' ') => 'price average'
                                                        const sortBy = req.query.sort.split(",").join(" ");
                                                        console.log(sortBy);
                                                        mongooseQuery = mongooseQuery.sort(sortBy);
                                                    } else {
                                                        mongooseQuery = mongooseQuery.sort("-createdAt");
                                                    }

                                                    // 4) Execute query
                                                    const products = await mongooseQuery;

                                                    if (!products) {
                                                        return next(new ApiError("Products not found", 404));
                                                    }
                                                    // res.status(200).json({ results: products.length, page, data: products });
                                                    res.status(200).json({
                                                        status: "success",
                                                        results: products.length,
                                                        page,
                                                        data: products,
                                                    });
                                    });


24- Apply Field Limiting Feature

        1- Apply Field Limiting Feature (we need these fields only) not all fields in response
            1- api => /products?fields=title,price,imageCover,ratingsAverage

            2- // fields limited
                    if(req.query.fields){
                        const fields = req.query.fields.split(",").join(" ")
                        mongooseQuery = mongooseQuery.select(fields)
                    }
        
        2- fields i don't need to include in the response
            1- api => /products?fields=-title,-price,-imageCover,-ratingsAverage
                        add - before field name you don't need to include in response
            2- // fields limited
                if(req.query.fields ){
                    const fields = req.query.fields.split(',').join(" ")
                    mongooseQuery = mongooseQuery.select(fields)
                }
        3- if we have not fields to include or exclude from the query then exclude this field
            to exclude (__v , createdAt, updatedAt )=> by default we can use select("-__v -createdAt -updatedAt")
             if(req.query.fields ){
                    const fields = req.query.fields.split(',').join(" ")
                    mongooseQuery = mongooseQuery.select(fields)
                }else{
                    mongooseQuery = mongooseQuery.select("-__v")
                }

                example: exports.getProducts = asyncHandler(async (req, res, next) => {
                                        // 1) filtering
                                        const queryStringObj = { ...req.query };
                                        const excludesFields = ["page", "sort", "limit", "fields"];
                                        excludesFields.forEach((field) => delete queryStringObj[field]);

                                        //apply filtration using [gte, gt, lte, lt]
                                        let queryString = JSON.stringify(queryStringObj);
                                        queryString = queryString.replace(
                                            /\b(gte|gt|lte|lt)\b/g,
                                            (match) => `$${match}`
                                        );
                                        const query = JSON.parse(queryString);

                                        // we need like this { price: { $gt: '109.95' }, ratingsAverage: { $gt: '4.3' } }
                                        // 2) pagination
                                        const page = req.query.page * 1 || 1;
                                        const limit = req.query.limit * 1 || 5;
                                        const skip = (page - 1) * limit;

                                        // 3) Build query // to can chain methods on the query
                                        let mongooseQuery = Product.find(query)
                                            .skip(skip)
                                            .limit(limit)
                                            .populate({ path: "category", select: "name -_id" });

                                        // 4) Sorting(one or list or nothing)
                                        if (req.query.sort) {
                                            // convert from 'price, average' => 'price average'
                                            // 'price, average' split(',') => ['price', 'average'] join(' ') => 'price average'
                                            const sortBy = req.query.sort.split(",").join(" ");
                                            mongooseQuery = mongooseQuery.sort(sortBy);
                                        } else {
                                            mongooseQuery = mongooseQuery.sort("-createdAt");
                                        }

                                        // 5) fields limitations
                                        if (req.query.fields) {
                                            const fields = req.query.fields.split(",").join(" ");
                                            mongooseQuery = mongooseQuery.select(fields);
                                        } else {
                                            mongooseQuery = mongooseQuery.select("-__v");
                                        }

                                        // 4) Execute query
                                        const products = await mongooseQuery;

                                        if (!products) {
                                            return next(new ApiError("Products not found", 404));
                                        }
                                        // res.status(200).json({ results: products.length, page, data: products });
                                        res.status(200).json({
                                            status: "success",
                                            results: products.length,
                                            page,
                                            data: products,
                                        });
                                        });

25- Searching using keyword

            api => /products?keyword=apple

                // Search (title, description)
                // .$or => to search products
                // $regex => to find
                // $options => insensitive litter  (APPLE = apple)
                if( req.query.keyword){
                    const query = {}
                    query.$or =[
                    {title: {$regex: req.query.keyword, $options: 'i'} },
                    {description: {$regex: req.query.keyword, $options: 'i'} },
                    ]

                    mongooseQuery = mongooseQuery.find(query)
                }                                     



